(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{281:function(t,e,n){"use strict";e.a={name:"VueRemarkRoot",render:function(t){return t("div",null,this.$slots.default)}}},752:function(t,e,n){"use strict";n.r(e);var o=n(0),i=n(54),a=(n(88),n(20),n(34),n(281)),r=n(1),s=(r.a.config.optionMergeStrategies,{VueRemarkRoot:a.a}),c=function(t){var e=t.options.components=t.options.components||{},n=t.options.computed=t.options.computed||{};Object.keys(s).forEach((function(t){"object"===Object(i.a)(s[t])&&"function"==typeof s[t].render?e[t]=s[t]:n[t]=function(){return s[t]}}))},u=r.a.config.optionMergeStrategies,p="__vueRemarkFrontMatter",l={excerpt:null,title:"Notational semantics"};var f=function(t){t.options[p]&&(t.options[p]=l),r.a.util.defineReactive(t.options,p,l),t.options.computed=u.computed({$frontmatter:function(){return t.options[p]}},t.options.computed)},m=Object(o.a)({},(function(){var t=this.$createElement,e=this._self._c||t;return e("VueRemarkRoot",[e("h1",{attrs:{id:"notational-semantics"}},[e("a",{attrs:{href:"#notational-semantics","aria-hidden":"true"}},[this._v("#")]),this._v("Notational semantics")]),e("p",[this._v("It is traditional in the programming language semantics community and literature to use double brace notation to denote the meaning function taking an expression, say e, in a source language, say S, to its interpretation in a target language, say T. More precisely, we type the meaning function ⟦-⟧ : S -> T, and write ⟦e⟧ to denote the application of the function to e. In general, such functions may take ancillary arguments, which are applied to the right. Thus, if the function is ⟦-⟧( - ) : S x A -> T we would write ⟦e⟧ ( a ). to denote the interpretation of e with the ancillary context a.")])])}),[],!1,null,null,null);"function"==typeof c&&c(m),"function"==typeof f&&f(m);e.default=m.exports}}]);